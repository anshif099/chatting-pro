<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WhatsApp‚Äëstyle Local Chat</title>
  <style>
    :root{--bg:#0a1014;--wa-green:#075E54;--wa-green-dark:#06453f;--wa-accent:#128C7E;--wa-chat:#DCF8C6;--panel:#0e151aee;--text:#e8edf1;--muted:#9fb0c9;--radius:18px;--blur:14px;}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, #1e293b55, transparent 60%),
        radial-gradient(1000px 700px at 90% 30%, #0ea5e944, transparent 60%),
        radial-gradient(1000px 700px at 50% 90%, #7c3aed33, transparent 60%),
        var(--bg);
      display:grid; place-items:center;
    }
    .shell{width:min(1100px, 95vw); height:min(90vh, 820px); position:relative;}

    .card{
      background: var(--panel);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      border: 1px solid #2a365570;
      box-shadow: 0 30px 60px #0008, inset 0 1px 0 #ffffff08;
      border-radius: var(--radius);
    }

    /*/* Auth */
    .auth{display:grid;grid-template-columns:1.1fr 1fr;gap:20px;padding:18px}
    .hero{position:relative;overflow:hidden;border-radius:var(--radius);background:linear-gradient(135deg,#06453f,#075E54,#128C7E)}
    .hero-inner{position:relative;padding:28px;height:100%;display:grid;align-content:space-between}
    .logo{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.5px}
    .logo-badge{width:42px;height:42px;border-radius:12px;background:#fff1;box-shadow:inset 0 1px 0 #fff6,0 10px 30px #0006}
    .tagline{color:#d9ebe7;line-height:1.5}
    .pill{display:inline-flex;align-items:center;gap:8px;font-size:12px;padding:8px 12px;border-radius:999px;background:#ffffff14;border:1px solid #ffffff3a}

    .auth-panel{padding:24px;display:grid;gap:14px}
    .tabs{display:flex;background:#0b1222aa;border-radius:12px;padding:6px;border:1px solid #1e2e33}
    .tab{flex:1;text-align:center;padding:10px 12px;border-radius:10px;cursor:pointer;user-select:none;color:var(--muted)}
    .tab.active{background:#0e1b1e;color:var(--text);border:1px solid #1e2e33}

    .field{display:grid;gap:8px}
    .field label{font-size:12px;color:#b7c0cf}
    .input{width:100%;background:#0b1214;border:1px solid #1e2e33;color:var(--text);border-radius:12px;padding:12px 14px;outline:none}
    .input:focus{border-color:#128C7E;box-shadow:0 0 0 3px #128C7E1e}

    .btn{cursor:pointer;border:0;border-radius:12px;padding:12px 14px;color:white;font-weight:700;letter-spacing:.3px;background:#128C7E;box-shadow:0 10px 25px #0007}
    .btn.secondary{background:#0b1214;border:1px solid #1e2e33;color:#d5def0;font-weight:600}
    .row{display:flex;gap:12px;align-items:center}
    .help{font-size:12px;color:#9fb0c9}
    .tiny{font-size:11px;color:#95a2b8}

    /*/* App */
    .app{display:grid;grid-template-columns:320px 1fr;gap:16px;padding:16px;height:100%}
    .sidebar{display:grid;grid-template-rows:auto 52px 1fr auto;gap:12px;padding:0;border-radius:var(--radius);overflow:hidden}
    .wa-topbar{background:#075E54;padding:12px 14px;display:flex;align-items:center;justify-content:space-between}
    .wa-title{font-weight:800}
    .wa-icons{opacity:.85}

    .search{background:#0b1214;border-top:1px solid #0f2327;border-bottom:1px solid #0f2327;padding:8px}
    .search input{width:100%;padding:10px 12px 10px 36px;border-radius:20px;background:#0f1a1d;border:1px solid #173035;color:var(--text)}
    .search svg{position:absolute;left:18px;top:50%;transform:translateY(-50%);opacity:.6}

    .threads{display:grid;gap:0;overflow:auto}
    .thread{display:flex;gap:12px;padding:12px;border-bottom:1px solid #0f2327;background:#0b1214;cursor:pointer}
    .thread:hover{background:#0f171a}
    .thread.active{background:#0f171a;outline:none}
    .avatar{width:42px;height:42px;border-radius:50%;background:#173035;display:grid;place-items:center;font-weight:700}
    .thread .meta{display:grid}
    .thread .meta .title{font-weight:700}
    .thread .meta .last{color:#9fb0c9;font-size:12px}

    .room{display:grid;grid-template-rows:auto 1fr auto; height:100%; overflow:hidden; border-radius:var(--radius); border:1px solid #0f2327; background:#0b1214}
    .room-head{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;background:#075E54;border-bottom:1px solid #06453f}
    .room-head .title{font-weight:800;letter-spacing:.2px}
    .room-head .badge{font-size:12px;color:#e8f7f2;background:#ffffff22;border:1px solid #ffffff3a;padding:6px 10px;border-radius:999px}

    .chat{padding:16px;overflow:auto;display:flex;flex-direction:column;gap:10px;background:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"220\" height=\"220\" viewBox=\"0 0 220 220\" opacity=\"0.06\"><circle cx=\"20\" cy=\"20\" r=\"2\" fill=\"white\"/></svg>') repeat}

    .msg{max-width:74%;padding:8px 10px;border-radius:16px;border:1px solid #0f2327;background:#111b1e;position:relative}
    .msg.me{margin-left:auto;background:#DCF8C6;color:#082b1f;border-color:#c6e8b2}
    .msg .time{font-size:11px;color:#9fb0c9;margin-top:4px;text-align:right}
    .msg.me .time{color:#2c5a51}
    .ticks{font-size:12px;margin-left:6px;opacity:.8}
    .ticks.read{color:#4ea3ff}

    .composer{display:flex;gap:10px;padding:10px;border-top:1px solid #0f2327;background:#0f171a}
    .composer .tool{background:#0f1a1d;border:1px solid #173035;border-radius:12px;padding:10px}
    .composer input{flex:1;padding:12px;border-radius:22px;border:1px solid #173035;background:#0f1a1d;color:var(--text)}
    .composer button.btn{background:#128C7E;border-radius:22px}

    .keybar{display:flex;gap:10px;padding:8px 12px;border-top:1px dashed #0f2327;background:#0f171a}
    .keybar input{flex:1;padding:10px;border-radius:10px;border:1px solid #173035;background:#0f1a1d;color:#dfe7fa}

    .empty{display:grid;place-items:center;color:#9fb0c9}

    .toast{position:fixed;right:16px;bottom:16px;background:#101a33;border:1px solid #223356;border-radius:12px;padding:12px 14px;box-shadow:0 10px 30px #0008}

    .hidden{display:none !important}
    @media(max-width:900px){.auth{grid-template-columns:1fr}.app{grid-template-columns:1fr}.me .name{display:none}}

    .toast{ position:fixed; right:16px; bottom:16px; background:#101a33; border:1px solid #223356; border-radius:12px; padding:12px 14px; box-shadow:0 10px 30px #0008 }

    .hidden{ display:none !important }
    @media(max-width: 900px){ .auth{ grid-template-columns:1fr } .app{ grid-template-columns:1fr } .me .name{ display:none } }
  </style>
</head>
<body>
  <div class="shell">

    <!-- ===== AUTH VIEW ===== -->
    <section id="auth" class="card auth">
      <div class="hero card">
        <div class="hero-inner">
          <div class="logo">
            <div class="logo-badge"></div>
            <div>
              <div style="font-size:20px">LuxChat</div>
              <div class="tiny">Private ‚Ä¢ Local ‚Ä¢ Elegant</div>
            </div>
          </div>

          <div>
            <div class="pill">No servers ‚Äî your messages are encrypted locally</div>
            <p class="tagline">Register or login to start a private, local-only chat experience. Messages are encrypted
              with a key you control (per-chat secret) and stored in your browser only.</p>
            <div class="tiny">Tip: open this page in two tabs, login with different usernames, join the same room & secret
              to simulate a 2‚Äëperson chat across tabs.</div>
          </div>
        </div>
      </div>

      <div class="auth-panel">
        <div class="tabs">
          <div class="tab active" data-tab="login">Login</div>
          <div class="tab" data-tab="register">Register</div>
        </div>

        <form id="loginForm" class="panel" autocomplete="off">
          <div class="field"><label>Username</label><input class="input" id="loginUser" required></div>
          <div class="field"><label>Password</label><input class="input" id="loginPass" type="password" required></div>
          <button class="btn" type="submit">Login</button>
          <div class="help">New here? Switch to <b>Register</b> above.</div>
        </form>

        <form id="registerForm" class="panel hidden" autocomplete="off">
          <div class="field"><label>Username</label><input class="input" id="regUser" required></div>
          <div class="field"><label>Password</label><input class="input" id="regPass" type="password" required></div>
          <div class="tiny">Your password protects your account and helps derive encryption keys.</div>
          <button class="btn" type="submit">Create Account</button>
        </form>

        <div class="tiny">Notifications: we'll ask for permission after login so you get a system alert on new messages.</div>
        <div class="tiny">Security: password is salted + PBKDF2-hashed; messages are AES‚ÄëGCM encrypted before saving locally.</div>
      </div>
    </section>

    <!-- ===== APP VIEW ===== -->
    <section id="app" class="app hidden">
      <aside class="sidebar card">
        <div class="wa-topbar">
          <div class="wa-title">LuxChat</div>
          <div class="wa-icons">üîç ‚ãÆ</div>
        </div>
        <div class="search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2"/></svg>
          <input id="search" placeholder="Search or start new chat‚Ä¶" />
        </div>
        <div class="threads" id="threads"></div>
        <div class="row" style="padding:10px">
          <input id="newRoom" class="input" placeholder="Room or contact"/>
          <button id="addRoom" class="btn secondary">New</button>
        </div>
        <button id="logoutBtn" class="btn secondary" style="margin:10px">Logout</button>
      </aside>

      <main id="roomPanel" class="room card"> id="roomPanel" class="room card">
        <header class="room-head">
          <div>
            <div class="title" id="roomTitle">No room selected</div>
            <div class="tiny" id="roomSub">Create or select a room on the left.</div>
          </div>
          <div class="badge" id="e2eBadge">E2E off</div>
        </header>

        <div id="chat" class="chat">
          <div class="empty">Select a room to start chatting.</div>
        </div>

        <div class="keybar">
          <input id="secret" placeholder="Per-room secret (both users must match)" />
          <button id="saveSecret" class="btn secondary">Set Secret</button>
          <span class="tiny" id="secretState">Not set</span>
        </div>

        <div class="composer">
          <div class="tool" title="Emoji">üòä</div>
          <div class="tool" title="Attach">üìé</div>
          <input id="message" placeholder="Type a message" maxlength="400"/>
          <button id="send" class="btn">‚û§</button>
        </div>
      </main>
    </section>

    <div class="toast hidden" id="toast"></div>
  </div>

  <script>
  /* =============================================
     LuxChat ‚Äî private, local-only chat (single file)
     Features:
      - Register/Login (PBKDF2 salted password hash in localStorage)
      - Rooms list stored locally per user
      - Per-room "secret" used to derive AES-GCM key; messages are encrypted at-rest
      - BroadcastChannel to sync messages across tabs (simulate multi-user on same device)
      - Notification API: prompts after login; shows system notification on new incoming chats
      - No external servers. No tracking. Works offline after first load.

     IMPORTANT (per your request):
     The Firebase config you provided is included below (commented). Not used here because all data stays local.

     // For Firebase JS SDK v7.20.0 and later, measurementId is optional
     const firebaseConfig = {
       apiKey: "AIzaSyAaxuleENvEkCeyGT-fpbD2MucqYqrTVKs",
       authDomain: "chating-37001.firebaseapp.com",
       databaseURL: "https://chating-37001-default-rtdb.firebaseio.com",
       projectId: "chating-37001",
       storageBucket: "chating-37001.firebasestorage.app",
       messagingSenderId: "34963823190",
       appId: "1:34963823190:web:1a799357de4b552564b9f7",
       measurementId: "G-FY3X1671VP"
     };
  ============================================== */

  // ---------- Utilities (crypto, storage, time, UI helpers)
  const enc = new TextEncoder();
  const dec = new TextDecoder();

  const ui = {
    qs: (sel, el=document)=> el.querySelector(sel),
    qsa: (sel, el=document)=> [...el.querySelectorAll(sel)],
    toast(msg){ const t=ui.qs('#toast'); t.textContent=msg; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'), 2200); },
    time(ts=Date.now()){ const d=new Date(ts); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); },
  };

  const store = {
    get(key, dflt){ try{ return JSON.parse(localStorage.getItem(key)) ?? dflt; }catch{ return dflt } },
    set(key, val){ localStorage.setItem(key, JSON.stringify(val)); },
    del(key){ localStorage.removeItem(key); }
  };

  async function hashPassword(pass, salt){
    const k = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveBits','deriveKey']);
    const s = salt || crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.deriveKey(
      {name:'PBKDF2', salt:s, iterations:120000, hash:'SHA-256'},
      k, {name:'AES-GCM', length:256}, true, ['encrypt','decrypt']
    );
    const raw = new Uint8Array(await crypto.subtle.exportKey('raw', key));
    return { hash: btoa(String.fromCharCode(...raw)), salt: Array.from(s) };
  }

  async function deriveRoomKey(username, roomId, secret){
    if(!secret) return null;
    const material = await crypto.subtle.importKey('raw', enc.encode(secret), 'PBKDF2', false, ['deriveKey']);
    const roomSalt = enc.encode(`${username}|${roomId}`); // different per user+room
    return await crypto.subtle.deriveKey(
      {name:'PBKDF2', salt:roomSalt, iterations:150000, hash:'SHA-256'},
      material, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']
    );
  }

  async function encrypt(key, text){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(text));
    return { iv: Array.from(iv), data: btoa(String.fromCharCode(...new Uint8Array(ct))) };
  }
  async function decrypt(key, payload){
    const iv = new Uint8Array(payload.iv);
    const buf = Uint8Array.from(atob(payload.data), c=>c.charCodeAt(0));
    const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, buf);
    return dec.decode(pt);
  }

  // ---------- App state
  const bc = ('BroadcastChannel' in self) ? new BroadcastChannel('luxchat') : null;
  const state = {
    user: null,
    currentRoom: null,
    keyCache: {},
    presence: {}, // room -> { users: Set }
    receipts: {}  // msgId -> 'sent'|'delivered'|'read'
  };

  // ---------- Auth
  const usersKey = 'luxchat_users';
  const sessionKey = 'luxchat_session';

  function loadUsers(){ return store.get(usersKey, {}); }
  function saveUsers(u){ store.set(usersKey, u); }

  function saveSession(username){ store.set(sessionKey,{username}); }
  function loadSession(){ return store.get(sessionKey,null); }
  function clearSession(){ store.del(sessionKey); }

  // ---------- Rooms & Messages storage
  function roomsKey(username){ return `luxchat_rooms_${username}`; }
  function msgsKey(username, roomId){ return `luxchat_msgs_${username}_${roomId}`; }

  function listRooms(username){ return store.get(roomsKey(username), []); }
  function saveRooms(username, rooms){ store.set(roomsKey(username), rooms); }

  function loadMsgs(username, roomId){ return store.get(msgsKey(username, roomId), []); }
  function saveMsgs(username, roomId, msgs){ store.set(msgsKey(username, roomId), msgs); }

  // ---------- Notifications
  async function ensureNotificationPermission(){
    if(!('Notification' in window)) return;
    if(Notification.permission === 'default'){
      try{ await Notification.requestPermission(); } catch{}
    }
  }
  function notify(title, body){
    if(!('Notification' in window)) return;
    if(document.hasFocus()) return; // avoid spamming when tab is active
    if(Notification.permission === 'granted'){
      new Notification(title, { body });
    }
  }

  // ---------- UI wiring
  const authView = ui.qs('#auth');
  const appView = ui.qs('#app');
  const loginForm = ui.qs('#loginForm');
  const registerForm = ui.qs('#registerForm');
  const tabs = ui.qsa('.tab');

  tabs.forEach(t=>t.addEventListener('click', ()=>{
    tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
    const mode = t.dataset.tab;
    loginForm.classList.toggle('hidden', mode!=='login');
    registerForm.classList.toggle('hidden', mode!=='register');
  }));

  registerForm.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username = ui.qs('#regUser').value.trim();
    const pass = ui.qs('#regPass').value;
    if(username.length < 3 || pass.length < 6){ return ui.toast('Username ‚â•3, Password ‚â•6'); }
    const users = loadUsers();
    if(users[username]) return ui.toast('Username already exists');
    const {hash, salt} = await hashPassword(pass);
    users[username] = { hash, salt };
    saveUsers(users);
    ui.toast('Account created. Please login.');
    tabs[0].click();
  });

  loginForm.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username = ui.qs('#loginUser').value.trim();
    const pass = ui.qs('#loginPass').value;
    const users = loadUsers(); const u = users[username];
    if(!u) return ui.toast('User not found');
    const {hash} = await hashPassword(pass, new Uint8Array(u.salt));
    if(hash !== u.hash) return ui.toast('Invalid password');
    state.user = { username };
    saveSession(username);
    await ensureNotificationPermission();
    enterApp();
  });

  function enterApp(){
    ui.qs('#meName').textContent = '@' + state.user.username;
    authView.classList.add('hidden');
    appView.classList.remove('hidden');
    renderRooms();
  }

  // Logout
  ui.qs('#logoutBtn').addEventListener('click', ()=>{
    clearSession(); state.user=null; state.currentRoom=null; state.keyCache={};
    appView.classList.add('hidden'); authView.classList.remove('hidden');
  });

  // Rooms
  ui.qs('#addRoom').addEventListener('click', ()=>{
    const roomId = ui.qs('#newRoom').value.trim(); if(!roomId) return;
    const rooms = listRooms(state.user.username);
    if(!rooms.includes(roomId)){ rooms.unshift(roomId); saveRooms(state.user.username, rooms); }
    ui.qs('#newRoom').value='';
    renderRooms(roomId);
  });
  ui.qs('#search').addEventListener('input', renderRooms);

  function renderRooms(selectRoom){
    const wrap = ui.qs('#threads'); wrap.innerHTML='';
    const q = ui.qs('#search').value.trim().toLowerCase();
    let rooms = listRooms(state.user.username);
    if(q) rooms = rooms.filter(r=>r.toLowerCase().includes(q));
    if(rooms.length===0){
      const div=document.createElement('div'); div.className='tiny'; div.textContent='No rooms yet. Join one below.'; wrap.appendChild(div);
    } else {
      rooms.forEach(r=>{
        const msgs = loadMsgs(state.user.username, r);
        const last = msgs[msgs.length-1];
        const el = document.createElement('div'); el.className='thread card thread' + (state.currentRoom===r?' active':'');
        el.innerHTML = `<div class="icon">üí¨</div>
          <div class="meta"><div class="title">${r}</div>
          <div class="last">${last? (last.me? 'You: ':'') + (last.preview||'') : 'No messages yet'}</div></div>`;
        el.addEventListener('click', ()=> openRoom(r));
        wrap.appendChild(el);
      });
    }
    if(selectRoom) openRoom(selectRoom);
  }

  async function openRoom(roomId){
    state.currentRoom = roomId;
    ui.qs('#roomTitle').textContent = roomId;
    ui.qs('#roomSub').textContent = 'Encrypted local messages';
    const secretSaved = store.get(`luxchat_secret_${state.user.username}_${roomId}`, null);
    ui.qs('#secret').value = secretSaved || '';
    await setSecret(false);
    renderChat();
  }

  async function setSecret(showToast=true){
    const s = ui.qs('#secret').value.trim();
    if(!state.currentRoom) return;
    if(s){
      const key = await deriveRoomKey(state.user.username, state.currentRoom, s);
      state.keyCache[state.currentRoom] = key;
      store.set(`luxchat_secret_${state.user.username}_${state.currentRoom}`, s);
      ui.qs('#e2eBadge').textContent='E2E on';
      ui.qs('#e2eBadge').style.borderColor = '#22c55e99';
      ui.qs('#secretState').textContent='Set';
      if(showToast) ui.toast('Secret set. New messages will be encrypted.');
    } else {
      delete state.keyCache[state.currentRoom];
      store.del(`luxchat_secret_${state.user.username}_${state.currentRoom}`);
      ui.qs('#e2eBadge').textContent='E2E off';
      ui.qs('#e2eBadge').style.borderColor = '#223356';
      ui.qs('#secretState').textContent='Not set';
      if(showToast) ui.toast('Secret removed.');
    }
  }
  ui.qs('#saveSecret').addEventListener('click', ()=> setSecret(true));

  // Chat render/send
  function renderChat(){
    const box = ui.qs('#chat'); box.innerHTML='';
    if(!state.currentRoom){ box.innerHTML = '<div class="empty">Select a room to start chatting.</div>'; return; }
    const msgs = loadMsgs(state.user.username, state.currentRoom);
    msgs.forEach(m=>{
      const div=document.createElement('div'); div.className='msg' + (m.me?' me':'');
      const ticks = m.me ? `<span class="ticks ${m.status==='read'?'read':''}">${m.status==='sent'?'‚úì':m.status==='delivered'?'‚úì‚úì':'‚úì‚úì'}</span>` : '';
      div.innerHTML = `${String(m.text).replace(/</g,'&lt;')}<div class="time">${ui.time(m.ts)} ${ticks}</div>`;
      box.appendChild(div);
    });
    box.scrollTop = box.scrollHeight;
  }

  async function sendMessage(){
    const input = ui.qs('#message'); const text = input.value.trim();
    if(!text || !state.currentRoom) return;
    const key = state.keyCache[state.currentRoom];
    let payload = null; let preview = text.slice(0, 40);
    if(key){ payload = await encrypt(key, text); }
    const id = crypto.randomUUID();
    const msg = { id, room: state.currentRoom, ts: Date.now(), from: state.user.username, me:true,
      text: key? 'üîí ' + preview + '‚Ä¶' : text, preview, status:'sent' };
    const msgs = loadMsgs(state.user.username, state.currentRoom); msgs.push(msg); saveMsgs(state.user.username, state.currentRoom, msgs);
    renderChat(); input.value='';

    // Broadcast to other tabs (ciphertext if key exists)
    const outgoing = { type:'msg', id, room: state.currentRoom, to: 'any', from: state.user.username, ts: msg.ts,
      ciphertext: payload, plaintext: key? null : text };
    if(bc) bc.postMessage(outgoing);
    const inboxKey = 'luxchat_inbox';
    const box = store.get(inboxKey, []); box.push(outgoing); store.set(inboxKey, box);
    // simulate delivery receipt to sender
    setTimeout(()=>{
      updateStatus(id,'delivered');
    }, 100);
  }
  ui.qs('#send').addEventListener('click', sendMessage);
  ui.qs('#message').addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessage(); }});

  // Receive via BroadcastChannel
  if(bc){ bc.onmessage = async (ev)=>{
    if(ev.data?.type==='msg') await handleIncoming(ev.data);
    if(ev.data?.type==='receipt') handleReceipt(ev.data);
  }; }
  window.addEventListener('storage', async (ev)=>{
    if(!ev.key) return;
    try{
      if(ev.key==='luxchat_inbox' && ev.newValue){
        const arr = JSON.parse(ev.newValue) || []; if(!arr.length) return; const item=arr[arr.length-1];
        if(item.type==='msg') await handleIncoming(item);
        if(item.type==='receipt') handleReceipt(item);
      }
    }catch{}
  }); } }catch{}
    }
  });

  async function handleIncoming(packet){
    if(!packet || packet.type!=='msg') return;
    const {id, room, from, ts, ciphertext, plaintext} = packet;
    const me = state?.user?.username; if(!me) return;
    const rooms = listRooms(me); if(!rooms.includes(room)) return;

    let shownText = plaintext; const key = state.keyCache[room];
    if(ciphertext && key){
      try{ shownText = await decrypt(key, ciphertext); }catch{ shownText = 'üîê Encrypted message (wrong secret)'; }
    } else if(ciphertext && !key){ shownText = 'üîê Encrypted message (secret not set)'; }

    const msg = { id, room, ts, from, me:false, text: shownText, preview: String(shownText).slice(0,40) };
    const msgs = loadMsgs(me, room); msgs.push(msg); saveMsgs(me, room, msgs);

    if(state.currentRoom===room) renderChat();
    notify(`New message from @${from}`, `Room: ${room}`);

    // send read vs delivered receipts based on focus & room
    const receipt = (document.hasFocus() && state.currentRoom===room) ? 'read' : 'delivered';
    const ack = { type:'receipt', id, room, status: receipt };
    if(bc) bc.postMessage(ack);
    const inboxKey = 'luxchat_inbox'; const box = store.get(inboxKey, []); box.push(ack); store.set(inboxKey, box);
  }

  function handleReceipt({id, room, status}){
    // update my copy of sent message
    if(status!=='sent'){
      const msgs = loadMsgs(state.user.username, room);
      const idx = msgs.findIndex(m=>m.id===id && m.me);
      if(idx>-1){ msgs[idx].status = status; saveMsgs(state.user.username, room, msgs); if(state.currentRoom===room) renderChat(); }
    }
  }

  function updateStatus(id, status){
    const room = state.currentRoom; if(!room) return;
    const msgs = loadMsgs(state.user.username, room);
    const idx = msgs.findIndex(m=>m.id===id && m.me);
    if(idx>-1){ msgs[idx].status = status; saveMsgs(state.user.username, room, msgs); renderChat(); }
  }

  // Session restore
  (async function init(){
    const session = loadSession();
    if(session){ state.user = { username: session.username }; enterApp(); }
  })();

  </script>
</body>
</html>
