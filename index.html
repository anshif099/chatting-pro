<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LuxChat ‚Äî Private Local Chat</title>
  <style>
    :root{
      --bg: #0b0f1a;
      --panel: #0f172aee;
      --panel-2: #0b1222cc;
      --text: #e6e9ef;
      --muted: #98a2b3;
      --brand: linear-gradient(135deg,#7c3aed,#4f46e5,#06b6d4);
      --accent: #7c3aed;
      --ok: #22c55e; --warn:#f59e0b; --err:#ef4444;
      --blur: 14px;
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 10% 10%, #1e293b55, transparent 60%),
        radial-gradient(1000px 700px at 90% 30%, #0ea5e944, transparent 60%),
        radial-gradient(1000px 700px at 50% 90%, #7c3aed33, transparent 60%),
        var(--bg);
      display:grid; place-items:center;
    }
    .shell{width:min(1100px, 95vw); height:min(90vh, 820px); position:relative;}

    .card{
      background: var(--panel);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      border: 1px solid #2a365570;
      box-shadow: 0 30px 60px #0008, inset 0 1px 0 #ffffff08;
      border-radius: var(--radius);
    }

    /* Auth */
    .auth{
      display:grid; grid-template-columns: 1.2fr 1fr; gap:20px; padding:18px;
    }
    .hero{ position:relative; overflow:hidden; border-radius: var(--radius);}
    .hero::before{
      content:""; position:absolute; inset:0; background:var(--brand); filter: blur(60px); opacity:.35;
    }
    .hero-inner{ position:relative; padding:28px; height:100%; display:grid; align-content:space-between; }
    .logo{display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.5px}
    .logo-badge{
      width:42px; height:42px; border-radius:12px; background:var(--brand);
      box-shadow: inset 0 1px 0 #fff8, 0 10px 30px #0006;
    }
    .tagline{color:#cbd5e1; line-height:1.4}
    .pill{
      display:inline-flex; align-items:center; gap:8px; font-size:12px; padding:8px 12px; border-radius:999px; background:#0ea5e922; border:1px solid #38bdf86e;
    }

    .auth-panel{ padding:24px; display:grid; gap:14px }
    .tabs{ display:flex; background:#0b1222aa; border-radius:12px; padding:6px; border:1px solid #243453; }
    .tab{ flex:1; text-align:center; padding:10px 12px; border-radius:10px; cursor:pointer; user-select:none; color:var(--muted)}
    .tab.active{ background:linear-gradient(180deg,#121c35,#0e1730); color:var(--text); border:1px solid #223356 }

    .field{ display:grid; gap:8px }
    .field label{ font-size:12px; color:#b7c0cf } 
    .input{ width:100%; background:#0b1222; border:1px solid #243453; color:var(--text); border-radius:12px; padding:12px 14px; outline:none }
    .input:focus{ border-color:#475d8a; box-shadow:0 0 0 3px #3b82f61a }

    .btn{ cursor:pointer; border:0; border-radius:12px; padding:12px 14px; color:white; font-weight:700; letter-spacing:.3px; background:var(--brand); box-shadow: 0 10px 25px #0007 }
    .btn.secondary{ background:#0b1222; border:1px solid #223356; color:#d5def0; font-weight:600 }
    .row{ display:flex; gap:12px; align-items:center }
    .help{ font-size:12px; color:#9fb0c9 }
    .tiny{ font-size:11px; color:#95a2b8 }

    /* App */
    .app{ display:grid; grid-template-columns: 300px 1fr; gap:16px; padding:16px; height:100% }
    .sidebar{ display:grid; grid-template-rows: auto 1fr auto; gap:12px; padding:14px }
    .me{ display:flex; align-items:center; gap:12px; padding:10px; border-radius:12px; background:linear-gradient(180deg,#101a33,#0d152b); border:1px solid #223356 }
    .me .avatar{ width:36px; height:36px; border-radius:12px; background:var(--brand) }
    .me .name{ font-weight:700 }

    .search{ position:relative }
    .search input{ width:100%; padding:12px 12px 12px 36px; border-radius:12px; background:#0b1222; border:1px solid #243453; color:var(--text) }
    .search svg{ position:absolute; left:10px; top:50%; transform:translateY(-50%); opacity:.6 }

    .threads{ display:grid; gap:8px; overflow:auto; padding-right:6px }
    .thread{ display:flex; gap:10px; padding:10px; border-radius:12px; background:#0b1222; border:1px solid #243453; cursor:pointer }
    .thread.active{ outline:2px solid #4f46e5aa }
    .thread .icon{ width:34px; height:34px; border-radius:10px; background:#111c37; display:grid; place-items:center }
    .thread .meta{ display:grid }
    .thread .meta .title{ font-weight:700 }
    .thread .meta .last{ color:#9fb0c9; font-size:12px }

    .room{
      display:grid; grid-template-rows: auto 1fr auto; height:100%; overflow:hidden; border-radius:var(--radius); border:1px solid #243453;
      background:linear-gradient(180deg,#0f172acc,#0b1222ee);
    }
    .room-head{ display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid #223356 }
    .room-head .title{ font-weight:800; letter-spacing:.4px }
    .room-head .badge{ font-size:12px; color:#a6b4cc; background:#0ea5e922; border:1px solid #38bdf86e; padding:6px 10px; border-radius:999px }

    .chat{ padding:16px; overflow:auto; display:flex; flex-direction:column; gap:10px }

    .msg{ max-width:78%; padding:12px 14px; border-radius:16px; border:1px solid #223356; background:#0b1222; position:relative }
    .msg.me{ margin-left:auto; background:linear-gradient(180deg,#1b2544,#121c35); border-color:#2f3f64 }
    .msg .time{ font-size:11px; color:#9fb0c9; margin-top:6px; text-align:right }

    .composer{ display:flex; gap:10px; padding:12px; border-top:1px solid #223356; background:#0b1222cc }
    .composer input{ flex:1; padding:12px; border-radius:12px; border:1px solid #243453; background:#0b1222; color:var(--text) }

    .keybar{ display:flex; gap:10px; padding:10px 16px; border-top:1px dashed #223356; background:#0c152acc }
    .keybar input{ flex:1; padding:10px; border-radius:10px; border:1px solid #253a64; background:#0b1222; color:#dfe7fa }
    .keybar .tiny{ opacity:.8 }

    .empty{ display:grid; place-items:center; color:#9fb0c9 }

    .toast{ position:fixed; right:16px; bottom:16px; background:#101a33; border:1px solid #223356; border-radius:12px; padding:12px 14px; box-shadow:0 10px 30px #0008 }

    .hidden{ display:none !important }
    @media(max-width: 900px){ .auth{ grid-template-columns:1fr } .app{ grid-template-columns:1fr } .me .name{ display:none } }
  </style>
</head>
<body>
  <div class="shell">

    <!-- ===== AUTH VIEW ===== -->
    <section id="auth" class="card auth">
      <div class="hero card">
        <div class="hero-inner">
          <div class="logo">
            <div class="logo-badge"></div>
            <div>
              <div style="font-size:20px">LuxChat</div>
              <div class="tiny">Private ‚Ä¢ Local ‚Ä¢ Elegant</div>
            </div>
          </div>

          <div>
            <div class="pill">No servers ‚Äî your messages are encrypted locally</div>
            <p class="tagline">Register or login to start a private, local-only chat experience. Messages are encrypted
              with a key you control (per-chat secret) and stored in your browser only.</p>
            <div class="tiny">Tip: open this page in two tabs, login with different usernames, join the same room & secret
              to simulate a 2‚Äëperson chat across tabs.</div>
          </div>
        </div>
      </div>

      <div class="auth-panel">
        <div class="tabs">
          <div class="tab active" data-tab="login">Login</div>
          <div class="tab" data-tab="register">Register</div>
        </div>

        <form id="loginForm" class="panel" autocomplete="off">
          <div class="field"><label>Username</label><input class="input" id="loginUser" required></div>
          <div class="field"><label>Password</label><input class="input" id="loginPass" type="password" required></div>
          <button class="btn" type="submit">Login</button>
          <div class="help">New here? Switch to <b>Register</b> above.</div>
        </form>

        <form id="registerForm" class="panel hidden" autocomplete="off">
          <div class="field"><label>Username</label><input class="input" id="regUser" required></div>
          <div class="field"><label>Password</label><input class="input" id="regPass" type="password" required></div>
          <div class="tiny">Your password protects your account and helps derive encryption keys.</div>
          <button class="btn" type="submit">Create Account</button>
        </form>

        <div class="tiny">Notifications: we'll ask for permission after login so you get a system alert on new messages.</div>
        <div class="tiny">Security: password is salted + PBKDF2-hashed; messages are AES‚ÄëGCM encrypted before saving locally.</div>
      </div>
    </section>

    <!-- ===== APP VIEW ===== -->
    <section id="app" class="app hidden">
      <aside class="sidebar card">
        <div class="me">
          <div class="avatar"></div>
          <div>
            <div class="name" id="meName">@me</div>
            <div class="tiny" id="meHint">Local user</div>
          </div>
        </div>

        <div class="search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><circle cx="11" cy="11" r="7" stroke="currentColor" stroke-width="2"/></svg>
          <input id="search" placeholder="Search rooms‚Ä¶" />
        </div>

        <div class="threads" id="threads"></div>

        <div class="row">
          <input id="newRoom" class="input" placeholder="Create or join room ID"/>
          <button id="addRoom" class="btn secondary">Join</button>
        </div>

        <button id="logoutBtn" class="btn secondary">Logout</button>
      </aside>

      <main id="roomPanel" class="room card">
        <header class="room-head">
          <div>
            <div class="title" id="roomTitle">No room selected</div>
            <div class="tiny" id="roomSub">Create or select a room on the left.</div>
          </div>
          <div class="badge" id="e2eBadge">E2E off</div>
        </header>

        <div id="chat" class="chat">
          <div class="empty">Select a room to start chatting.</div>
        </div>

        <div class="keybar">
          <input id="secret" placeholder="Per-room secret (both users must match)" />
          <button id="saveSecret" class="btn secondary">Set Secret</button>
          <span class="tiny" id="secretState">Not set</span>
        </div>

        <div class="composer">
          <input id="message" placeholder="Write a message‚Ä¶ (text only)" maxlength="400"/>
          <button id="send" class="btn">Send</button>
        </div>
      </main>
    </section>

    <div class="toast hidden" id="toast"></div>
  </div>

  <script>
  /* =============================================
     LuxChat ‚Äî private, local-only chat (single file)
     Features:
      - Register/Login (PBKDF2 salted password hash in localStorage)
      - Rooms list stored locally per user
      - Per-room "secret" used to derive AES-GCM key; messages are encrypted at-rest
      - BroadcastChannel to sync messages across tabs (simulate multi-user on same device)
      - Notification API: prompts after login; shows system notification on new incoming chats
      - No external servers. No tracking. Works offline after first load.

     IMPORTANT (per your request):
     The Firebase config you provided is included below (commented). Not used here because all data stays local.

     // For Firebase JS SDK v7.20.0 and later, measurementId is optional
     const firebaseConfig = {
       apiKey: "AIzaSyAaxuleENvEkCeyGT-fpbD2MucqYqrTVKs",
       authDomain: "chating-37001.firebaseapp.com",
       databaseURL: "https://chating-37001-default-rtdb.firebaseio.com",
       projectId: "chating-37001",
       storageBucket: "chating-37001.firebasestorage.app",
       messagingSenderId: "34963823190",
       appId: "1:34963823190:web:1a799357de4b552564b9f7",
       measurementId: "G-FY3X1671VP"
     };
  ============================================== */

  // ---------- Utilities (crypto, storage, time, UI helpers)
  const enc = new TextEncoder();
  const dec = new TextDecoder();

  const ui = {
    qs: (sel, el=document)=> el.querySelector(sel),
    qsa: (sel, el=document)=> [...el.querySelectorAll(sel)],
    toast(msg){ const t=ui.qs('#toast'); t.textContent=msg; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'), 2200); },
    time(ts=Date.now()){ const d=new Date(ts); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); },
  };

  const store = {
    get(key, dflt){ try{ return JSON.parse(localStorage.getItem(key)) ?? dflt; }catch{ return dflt } },
    set(key, val){ localStorage.setItem(key, JSON.stringify(val)); },
    del(key){ localStorage.removeItem(key); }
  };

  async function hashPassword(pass, salt){
    const k = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveBits','deriveKey']);
    const s = salt || crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.deriveKey(
      {name:'PBKDF2', salt:s, iterations:120000, hash:'SHA-256'},
      k, {name:'AES-GCM', length:256}, true, ['encrypt','decrypt']
    );
    const raw = new Uint8Array(await crypto.subtle.exportKey('raw', key));
    return { hash: btoa(String.fromCharCode(...raw)), salt: Array.from(s) };
  }

  async function deriveRoomKey(username, roomId, secret){
    if(!secret) return null;
    const material = await crypto.subtle.importKey('raw', enc.encode(secret), 'PBKDF2', false, ['deriveKey']);
    const roomSalt = enc.encode(`${username}|${roomId}`); // different per user+room
    return await crypto.subtle.deriveKey(
      {name:'PBKDF2', salt:roomSalt, iterations:150000, hash:'SHA-256'},
      material, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']
    );
  }

  async function encrypt(key, text){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(text));
    return { iv: Array.from(iv), data: btoa(String.fromCharCode(...new Uint8Array(ct))) };
  }
  async function decrypt(key, payload){
    const iv = new Uint8Array(payload.iv);
    const buf = Uint8Array.from(atob(payload.data), c=>c.charCodeAt(0));
    const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, buf);
    return dec.decode(pt);
  }

  // ---------- App state
  const bc = ('BroadcastChannel' in self) ? new BroadcastChannel('luxchat') : null;
  const state = {
    user: null, // { username }
    currentRoom: null, // roomId string
    keyCache: {}, // roomId -> CryptoKey
  };

  // ---------- Auth
  const usersKey = 'luxchat_users';
  const sessionKey = 'luxchat_session';

  function loadUsers(){ return store.get(usersKey, {}); }
  function saveUsers(u){ store.set(usersKey, u); }

  function saveSession(username){ store.set(sessionKey,{username}); }
  function loadSession(){ return store.get(sessionKey,null); }
  function clearSession(){ store.del(sessionKey); }

  // ---------- Rooms & Messages storage
  function roomsKey(username){ return `luxchat_rooms_${username}`; }
  function msgsKey(username, roomId){ return `luxchat_msgs_${username}_${roomId}`; }

  function listRooms(username){ return store.get(roomsKey(username), []); }
  function saveRooms(username, rooms){ store.set(roomsKey(username), rooms); }

  function loadMsgs(username, roomId){ return store.get(msgsKey(username, roomId), []); }
  function saveMsgs(username, roomId, msgs){ store.set(msgsKey(username, roomId), msgs); }

  // ---------- Notifications
  async function ensureNotificationPermission(){
    if(!('Notification' in window)) return;
    if(Notification.permission === 'default'){
      try{ await Notification.requestPermission(); } catch{}
    }
  }
  function notify(title, body){
    if(!('Notification' in window)) return;
    if(document.hasFocus()) return; // avoid spamming when tab is active
    if(Notification.permission === 'granted'){
      new Notification(title, { body });
    }
  }

  // ---------- UI wiring
  const authView = ui.qs('#auth');
  const appView = ui.qs('#app');
  const loginForm = ui.qs('#loginForm');
  const registerForm = ui.qs('#registerForm');
  const tabs = ui.qsa('.tab');

  tabs.forEach(t=>t.addEventListener('click', ()=>{
    tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
    const mode = t.dataset.tab;
    loginForm.classList.toggle('hidden', mode!=='login');
    registerForm.classList.toggle('hidden', mode!=='register');
  }));

  registerForm.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username = ui.qs('#regUser').value.trim();
    const pass = ui.qs('#regPass').value;
    if(username.length < 3 || pass.length < 6){ return ui.toast('Username ‚â•3, Password ‚â•6'); }
    const users = loadUsers();
    if(users[username]) return ui.toast('Username already exists');
    const {hash, salt} = await hashPassword(pass);
    users[username] = { hash, salt };
    saveUsers(users);
    ui.toast('Account created. Please login.');
    tabs[0].click();
  });

  loginForm.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username = ui.qs('#loginUser').value.trim();
    const pass = ui.qs('#loginPass').value;
    const users = loadUsers(); const u = users[username];
    if(!u) return ui.toast('User not found');
    const {hash} = await hashPassword(pass, new Uint8Array(u.salt));
    if(hash !== u.hash) return ui.toast('Invalid password');
    state.user = { username };
    saveSession(username);
    await ensureNotificationPermission();
    enterApp();
  });

  function enterApp(){
    ui.qs('#meName').textContent = '@' + state.user.username;
    authView.classList.add('hidden');
    appView.classList.remove('hidden');
    renderRooms();
  }

  // Logout
  ui.qs('#logoutBtn').addEventListener('click', ()=>{
    clearSession(); state.user=null; state.currentRoom=null; state.keyCache={};
    appView.classList.add('hidden'); authView.classList.remove('hidden');
  });

  // Rooms
  ui.qs('#addRoom').addEventListener('click', ()=>{
    const roomId = ui.qs('#newRoom').value.trim(); if(!roomId) return;
    const rooms = listRooms(state.user.username);
    if(!rooms.includes(roomId)){ rooms.unshift(roomId); saveRooms(state.user.username, rooms); }
    ui.qs('#newRoom').value='';
    renderRooms(roomId);
  });
  ui.qs('#search').addEventListener('input', renderRooms);

  function renderRooms(selectRoom){
    const wrap = ui.qs('#threads'); wrap.innerHTML='';
    const q = ui.qs('#search').value.trim().toLowerCase();
    let rooms = listRooms(state.user.username);
    if(q) rooms = rooms.filter(r=>r.toLowerCase().includes(q));
    if(rooms.length===0){
      const div=document.createElement('div'); div.className='tiny'; div.textContent='No rooms yet. Join one below.'; wrap.appendChild(div);
    } else {
      rooms.forEach(r=>{
        const msgs = loadMsgs(state.user.username, r);
        const last = msgs[msgs.length-1];
        const el = document.createElement('div'); el.className='thread card thread' + (state.currentRoom===r?' active':'');
        el.innerHTML = `<div class="icon">üí¨</div>
          <div class="meta"><div class="title">${r}</div>
          <div class="last">${last? (last.me? 'You: ':'') + (last.preview||'') : 'No messages yet'}</div></div>`;
        el.addEventListener('click', ()=> openRoom(r));
        wrap.appendChild(el);
      });
    }
    if(selectRoom) openRoom(selectRoom);
  }

  async function openRoom(roomId){
    state.currentRoom = roomId;
    ui.qs('#roomTitle').textContent = roomId;
    ui.qs('#roomSub').textContent = 'Encrypted local messages';
    const secretSaved = store.get(`luxchat_secret_${state.user.username}_${roomId}`, null);
    ui.qs('#secret').value = secretSaved || '';
    await setSecret(false);
    renderChat();
  }

  async function setSecret(showToast=true){
    const s = ui.qs('#secret').value.trim();
    if(!state.currentRoom) return;
    if(s){
      const key = await deriveRoomKey(state.user.username, state.currentRoom, s);
      state.keyCache[state.currentRoom] = key;
      store.set(`luxchat_secret_${state.user.username}_${state.currentRoom}`, s);
      ui.qs('#e2eBadge').textContent='E2E on';
      ui.qs('#e2eBadge').style.borderColor = '#22c55e99';
      ui.qs('#secretState').textContent='Set';
      if(showToast) ui.toast('Secret set. New messages will be encrypted.');
    } else {
      delete state.keyCache[state.currentRoom];
      store.del(`luxchat_secret_${state.user.username}_${state.currentRoom}`);
      ui.qs('#e2eBadge').textContent='E2E off';
      ui.qs('#e2eBadge').style.borderColor = '#223356';
      ui.qs('#secretState').textContent='Not set';
      if(showToast) ui.toast('Secret removed.');
    }
  }
  ui.qs('#saveSecret').addEventListener('click', ()=> setSecret(true));

  // Chat render/send
  function renderChat(){
    const box = ui.qs('#chat'); box.innerHTML='';
    if(!state.currentRoom){ box.innerHTML = '<div class="empty">Select a room to start chatting.</div>'; return; }
    const msgs = loadMsgs(state.user.username, state.currentRoom);
    msgs.forEach(m=>{
      const div=document.createElement('div'); div.className='msg' + (m.me?' me':'');
      div.innerHTML = `${m.text.replace(/</g,'&lt;')}<div class="time">${ui.time(m.ts)}</div>`;
      box.appendChild(div);
    });
    box.scrollTop = box.scrollHeight;
  }

  async function sendMessage(){
    const input = ui.qs('#message'); const text = input.value.trim();
    if(!text || !state.currentRoom) return;
    const key = state.keyCache[state.currentRoom];
    let payload = null; let preview = text.slice(0, 40);
    if(key){ payload = await encrypt(key, text); }
    const msg = { id: crypto.randomUUID(), room: state.currentRoom, ts: Date.now(), from: state.user.username, me:true,
      text: key? 'üîí ' + preview + '‚Ä¶' : text, preview };
    const msgs = loadMsgs(state.user.username, state.currentRoom); msgs.push(msg); saveMsgs(state.user.username, state.currentRoom, msgs);
    renderChat(); input.value='';

    // Broadcast to other tabs (ciphertext if key exists)
    const outgoing = { type:'msg', room: state.currentRoom, to: 'any', from: state.user.username, ts: msg.ts,
      ciphertext: payload, plaintext: key? null : text };
    if(bc) bc.postMessage(outgoing);
    // Also mirror in a shared inbox list so other logged-in users on same device can pick up via storage event
    const inboxKey = 'luxchat_inbox';
    const box = store.get(inboxKey, []); box.push(outgoing); store.set(inboxKey, box);
  }
  ui.qs('#send').addEventListener('click', sendMessage);
  ui.qs('#message').addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendMessage(); }});

  // Receive via BroadcastChannel
  if(bc){ bc.onmessage = async (ev)=>{ await handleIncoming(ev.data); }; }
  window.addEventListener('storage', async (ev)=>{
    if(ev.key==='luxchat_inbox' && ev.newValue){
      try{ const arr = JSON.parse(ev.newValue) || []; if(arr.length){ const item=arr[arr.length-1]; await handleIncoming(item); } }catch{}
    }
  });

  async function handleIncoming(packet){
    if(!packet || packet.type!=='msg') return;
    const {room, from, ts, ciphertext, plaintext} = packet;
    const me = state?.user?.username;
    if(!me) return; // not logged in
    // Only show to users who have joined the room locally
    const rooms = listRooms(me);
    if(!rooms.includes(room)) return;

    let shownText = plaintext;
    const key = state.keyCache[room];
    if(ciphertext && key){
      try{ shownText = await decrypt(key, ciphertext); }catch{ shownText = 'üîê Encrypted message (wrong secret)'; }
    } else if(ciphertext && !key){ shownText = 'üîê Encrypted message (secret not set)'; }

    const msg = { id: crypto.randomUUID(), room, ts, from, me:false, text: shownText, preview: String(shownText).slice(0,40) };
    const msgs = loadMsgs(me, room); msgs.push(msg); saveMsgs(me, room, msgs);

    if(state.currentRoom===room) renderChat();
    notify(`New message from @${from}`, `Room: ${room}`);
  }

  // Session restore
  (async function init(){
    const session = loadSession();
    if(session){ state.user = { username: session.username }; enterApp(); }
  })();

  </script>
</body>
</html>
